"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProductRepository = void 0;
const _models_1 = require("../models");
const utils_1 = require("@medusajs/framework/utils");
const postgresql_1 = require("@mikro-orm/postgresql");
// eslint-disable-next-line max-len
class ProductRepository extends utils_1.DALUtils.mikroOrmBaseRepositoryFactory(_models_1.Product) {
    constructor(...args) {
        // @ts-ignore
        super(...arguments);
    }
    async deepUpdate(updates, validateVariantOptions, context = {}) {
        updates.forEach((update) => this.correctUpdateDTOTypes(update));
        const products = await this.find((0, utils_1.buildQuery)({ id: updates.map((p) => p.id) }, { relations: ["*"] }), context);
        const productsMap = new Map(products.map((p) => [p.id, p]));
        for (const update of updates) {
            const product = productsMap.get(update.id);
            // Assign the options first, so they'll be available for the variants loop below
            if (update.options) {
                (0, postgresql_1.wrap)(product).assign({ options: update.options });
                delete update.options; // already assigned above, so no longer necessary
            }
            if (update.variants) {
                validateVariantOptions(update.variants, product.options);
                update.variants.forEach((variant) => {
                    if (variant.options) {
                        variant.options = Object.entries(variant.options).map(([key, value]) => {
                            const productOption = product.options.find((option) => option.title === key);
                            const productOptionValue = productOption.values?.find((optionValue) => optionValue.value === value);
                            return productOptionValue.id;
                        });
                    }
                });
            }
            if (update.tags) {
                update.tags = update.tags.map((t) => t.id);
            }
            if (update.categories) {
                update.categories = update.categories.map((c) => c.id);
            }
            if (update.images) {
                update.images = update.images.map((image, index) => ({
                    ...image,
                    rank: index,
                }));
            }
            (0, postgresql_1.wrap)(product).assign(update);
        }
        // Doing this to ensure updates are returned in the same order they were provided,
        // since some core flows rely on this.
        // This is a high level of coupling though.
        return updates
            .map((update) => productsMap.get(update.id))
            .filter((product) => product !== undefined);
    }
    // We should probably fix the column types in the database to avoid this
    // It would also match the types in ProductVariant, which are already numbers
    correctUpdateDTOTypes(update) {
        update.weight = update.weight?.toString();
        update.length = update.length?.toString();
        update.height = update.height?.toString();
        update.width = update.width?.toString();
    }
    /**
     * In order to be able to have a strict not in categories, and prevent a product
     * to be return in the case it also belongs to other categories, we need to
     * first find all products that are in the categories, and then exclude them
     */
    async mutateNotInCategoriesConstraints(findOptions = {
        where: {},
    }, context = {}) {
        const manager = this.getActiveManager(context);
        if ("categories" in findOptions.where &&
            findOptions.where.categories?.id?.["$nin"]) {
            const productsInCategories = await manager.find(this.entity, {
                categories: {
                    id: { $in: findOptions.where.categories.id["$nin"] },
                },
            }, {
                fields: ["id"],
            });
            const productIds = productsInCategories.map((product) => product.id);
            if (productIds.length) {
                findOptions.where.id = { $nin: productIds };
                delete findOptions.where.categories?.id;
                if (Object.keys(findOptions.where.categories).length === 0) {
                    delete findOptions.where.categories;
                }
            }
        }
    }
}
exports.ProductRepository = ProductRepository;
//# sourceMappingURL=product.js.map